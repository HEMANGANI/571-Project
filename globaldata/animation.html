<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Global COVID Choropleth Map</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body { font-family: sans-serif; margin: 0; padding: 20px; }
    h2 {
      text-align: center;
      margin-bottom: 10px;
    }
    .map-container {
      display: flex;
      justify-content: center;
      align-items: center;
    }
    #controls, #timeline-controls {
      text-align: center;
      margin: 10px 0;
    }
    #tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.75);
      color: white;
      padding: 6px 10px;
      border-radius: 5px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      font-size: 0.9em;
    }
    svg {
      display: block;
      margin: auto;
    }
  </style>
</head>
<body>
  <h2>Global COVID-19 Choropleth Map (Time Series)</h2>

  <div id="controls">
    <label>
      Select metric:
      <select id="metric-select">
        <option value="cases">Confirmed</option>
        <option value="deaths">Deaths</option>
        <option value="recovered">Recovered</option>
      </select>
    </label>
  </div>

  <div id="timeline-controls">
    <button id="play-pause">Play</button>
    <input type="range" id="date-slider" min="0" max="0" step="1" value="0" style="width: 300px;">
    <div id="current-date" style="margin-top: 10px; font-weight: bold;"></div>
  </div>

  <div class="map-container">
    <svg id="map" width="1000" height="550"></svg>
  </div>

  <div id="tooltip"></div>

  <script>
    const svg = d3.select("#map");
    const tooltip = document.getElementById("tooltip");
    const width = 1000;
    const height = 550;

    const projection = d3.geoMercator().scale(150).translate([width / 2, height / 1.4]);
    const path = d3.geoPath().projection(projection);
    const color = d3.scaleSequential(d3.interpolateOrRd);

    let covidData = {};
    let world, population;

    function processTimeSeriesData(rawData) {
      const dateKeys = Object.keys(rawData[0]).slice(4);
      const countryMap = new Map();

      rawData.forEach(row => {
        const country = row["Country/Region"];
        if (!countryMap.has(country)) {
          countryMap.set(country, Array(dateKeys.length).fill(0));
        }
        const totals = countryMap.get(country);
        dateKeys.forEach((date, i) => {
          totals[i] += +row[date];
        });
      });

      return { data: countryMap, dates: dateKeys };
    }

    async function loadData() {
      const [confirmed, deaths, recovered, worldGeo, popData] = await Promise.all([
        d3.csv("data/confirmed.csv"),
        d3.csv("data/death.csv"),
        d3.csv("data/recovery.csv"),
        d3.json("data/world.json"),
        d3.json("data/population.json")
      ]);

      const confirmedData = processTimeSeriesData(confirmed);
      const deathsData = processTimeSeriesData(deaths);
      const recoveredData = processTimeSeriesData(recovered);

      const dates = confirmedData.dates;
      covidData = {};

      for (let i = 0; i < dates.length; i++) {
        const day = dates[i];
        covidData[day] = {};
        confirmedData.data.forEach((arr, country) => {
          covidData[day][country] = {
            cases: arr[i],
            deaths: deathsData.data.get(country)?.[i] || 0,
            recovered: recoveredData.data.get(country)?.[i] || 0
          };
        });
      }

      world = worldGeo;
      population = popData;

      setupTimeline(dates);
      drawMap("cases", dates[0]);
    }

    function drawMap(metric, date) {
      svg.selectAll("*").remove();

      const values = Object.values(covidData[date])
        .map(d => d[metric])
        .filter(v => v !== undefined && !isNaN(v));

      const maxValue = d3.quantile(values.sort(d3.ascending), 0.98);
      color.domain([0, maxValue]);

      svg.append("g")
        .selectAll("path")
        .data(world.features)
        .enter()
        .append("path")
        .attr("d", path)
        .attr("fill", d => {
          const name = d.properties.name;
          const val = covidData[date]?.[name]?.[metric];
          return val ? color(Math.min(val, maxValue)) : "#ccc";
        })
        .attr("stroke", "#999")
        .attr("stroke-width", 0.5)
        .on("mouseover", function(event, d) {
          const name = d.properties.name;
          const val = covidData[date]?.[name]?.[metric];
          d3.select(this).attr("stroke-width", 1.5).attr("stroke", "#000");
          tooltip.style.opacity = 1;
          tooltip.innerHTML = `<strong>${name}</strong><br>${metric}: ${val ? d3.format(",")(val) : "No data"}`;
        })
        .on("mousemove", event => {
          tooltip.style.left = `${event.pageX + 10}px`;
          tooltip.style.top = `${event.pageY + 10}px`;
        })
        .on("mouseout", function() {
          d3.select(this).attr("stroke-width", 0.5).attr("stroke", "#999");
          tooltip.style.opacity = 0;
        });

      // Legend
      const legendWidth = 300;
      const legendHeight = 10;
      const legendSvg = svg.append("g")
        .attr("transform", `translate(${width / 2 - legendWidth / 2}, ${height - 30})`);

      const gradient = svg.append("defs")
        .append("linearGradient")
        .attr("id", "legend-gradient")
        .attr("x1", "0%").attr("x2", "100%")
        .attr("y1", "0%").attr("y2", "0%");

      for (let i = 0; i <= 100; i++) {
        gradient.append("stop")
          .attr("offset", `${i}%`)
          .attr("stop-color", color(maxValue * i / 100));
      }

      legendSvg.append("rect")
        .attr("width", legendWidth)
        .attr("height", legendHeight)
        .style("fill", "url(#legend-gradient)");

      const legendScale = d3.scaleLinear()
        .domain([0, maxValue])
        .range([0, legendWidth]);

      const legendAxis = d3.axisBottom(legendScale)
        .ticks(5)
        .tickFormat(d => d3.format(".2s")(d).replace("G", "B"));

      legendSvg.append("g")
        .attr("transform", `translate(0, ${legendHeight})`)
        .call(legendAxis);
    }

    function setupTimeline(dates) {
      const slider = document.getElementById("date-slider");
      const playPause = document.getElementById("play-pause");
      const currentDate = document.getElementById("current-date");
      let playing = false;
      let currentIndex = 0;
      let interval;
      let metric = document.getElementById("metric-select").value;

      slider.max = dates.length - 1;

      function update() {
        const date = dates[currentIndex];
        drawMap(metric, date);
        currentDate.innerText = `Date: ${date}`;
        slider.value = currentIndex;
      }

      slider.oninput = () => {
        currentIndex = +slider.value;
        update();
      };

      playPause.onclick = () => {
        if (playing) {
          clearInterval(interval);
          playPause.innerText = "Play";
        } else {
          interval = setInterval(() => {
            currentIndex = (currentIndex + 1) % dates.length;
            update();
          }, 300);
          playPause.innerText = "Pause";
        }
        playing = !playing;
      };

      document.getElementById("metric-select").addEventListener("change", e => {
        metric = e.target.value;
        update();
      });

      update();
    }

    loadData();
  </script>
</body>
</html>
